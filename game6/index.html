<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ã‚¢ã‚¹ãƒˆãƒ­ãƒ»ãƒ•ã‚¡ãƒ¼ãƒãƒ¼ v2</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            display: flex;
            justify_content: center;
            align-items: center;
            height: 100vh;
            color: #fff;
            font-family: 'Courier New', sans-serif; /* ãƒ¬ãƒˆãƒ­æ„Ÿã®ã‚ã‚‹ãƒ•ã‚©ãƒ³ãƒˆ */
            overflow: hidden;
        }
        canvas {
            background-color: #000;
            border: 2px solid #333;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            font-size: 20px;
            text-shadow: 2px 2px 0 #000;
        }
        #shield-display {
            color: #00FFFF;
            margin-top: 5px;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas" width="600" height="800"></canvas>
<div id="ui">
    <div>SCORE: <span id="score">0</span></div>
    <div id="shield-display">SHIELD: <span id="shield-count">0</span></div>
</div>

<script>
/* =========================================
   ã‚²ãƒ¼ãƒ è¨­å®š
   ========================================= */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const shieldEl = document.getElementById('shield-count');

// ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
let gameState = 'START'; // START, PLAYING, GAMEOVER, WAITING
let score = 0;
let frames = 0;
let difficulty = 1; // é›£æ˜“åº¦ä¿‚æ•°

// å…¥åŠ›ç®¡ç†
const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Space: false };

// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š
const player = {
    x: 300, y: 700, w: 30, h: 50, speed: 5,
    color: 'white',
    bullets: [],
    lastShotTime: 0,
    shotDelay: 8, // åŸºæœ¬æ”»æ’ƒåŠ›ã¯ä¸€å®š
    shield: 0,    // ç¾åœ¨ã®ã‚·ãƒ¼ãƒ«ãƒ‰æšæ•°
    maxShield: 3,
    invincible: 0 // ç„¡æ•µæ™‚é–“ãƒ•ãƒ¬ãƒ¼ãƒ 
};

// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†
let enemies = [];
let enemyBullets = [];
let powerUps = [];
let particles = [];
let retryTimer = null; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å¾Œã®ã‚¿ã‚¤ãƒãƒ¼ç”¨

/* =========================================
   ã‚¯ãƒ©ã‚¹å®šç¾©
   ========================================= */

// æ•µã‚¯ãƒ©ã‚¹
class Enemy {
    constructor() {
        this.w = 40;
        this.h = 40;
        this.x = Math.random() * (canvas.width - this.w);
        this.y = -50;
        // é›£æ˜“åº¦ã«å¿œã˜ã¦å°‘ã—é€Ÿåº¦å¤‰åŒ–ã®å¹…ã‚’æŒãŸã›ã‚‹
        this.speedY = Math.random() * 3 + 2 + (difficulty * 0.1); 
        this.speedX = Math.random() * 2 - 1;
        this.color = '#ff3333';
        this.shootTimer = Math.random() * 100;
    }

    update() {
        this.y += this.speedY;
        this.x += this.speedX;
        if (this.x < 0 || this.x > canvas.width - this.w) this.speedX *= -1;

        // å¼¾å¹•ç™ºå°„é »åº¦ã‚‚é›£æ˜“åº¦ã§å°‘ã—ä¸ŠãŒã‚‹
        this.shootTimer++;
        let shootThreshold = Math.max(40, 90 - (difficulty * 2)); 
        
        if (this.shootTimer > shootThreshold) { 
            this.shoot();
            this.shootTimer = 0;
        }
    }

    shoot() {
        // æ•µã®å¼¾ï¼šè¦–èªæ€§ã‚¢ãƒƒãƒ—ã®ãŸã‚å°‘ã—å¤§ããã€æ˜ã‚‹ã
        const bx = this.x + this.w / 2;
        const by = this.y + this.h;
        enemyBullets.push(new EnemyBullet(bx, by, 0));
        enemyBullets.push(new EnemyBullet(bx, by, -2.5));
        enemyBullets.push(new EnemyBullet(bx, by, 2.5));
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        // æ•µã®ãƒ‡ã‚¶ã‚¤ãƒ³ï¼ˆç°¡æ˜“çš„ãªç›®ï¼‰
        ctx.fillStyle = 'black';
        ctx.fillRect(this.x + 10, this.y + 10, 5, 5);
        ctx.fillRect(this.x + 25, this.y + 10, 5, 5);
    }
}

// æ•µã®å¼¾ï¼ˆè¦–èªæ€§æ”¹å–„ç‰ˆï¼‰
class EnemyBullet {
    constructor(x, y, dx) {
        this.x = x;
        this.y = y;
        this.r = 7; // ã‚µã‚¤ã‚ºã‚¢ãƒƒãƒ—
        this.dy = 5; // é€Ÿåº¦
        this.dx = dx;
    }
    update() {
        this.y += this.dy;
        this.x += this.dx;
    }
    draw() {
        ctx.save();
        // ãƒã‚ªãƒ³ãƒ”ãƒ³ã‚¯ã§ç™ºå…‰ã•ã›ã‚‹
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#ff00ff"; 
        ctx.fillStyle = '#ff00cc';
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // ä¸­å¿ƒã«ç™½ã„èŠ¯ã‚’æã„ã¦è¦‹ã‚„ã™ãã™ã‚‹
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r/2, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ã‚·ãƒ¼ãƒ«ãƒ‰ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‹ã‚‰å¤‰æ›´ï¼‰
class ShieldItem {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 25;
        this.h = 25;
        this.dy = 2.5;
    }
    update() {
        this.y += this.dy;
    }
    draw() {
        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = "#00ffff";
        ctx.fillStyle = '#00ffff'; // ã‚·ã‚¢ãƒ³è‰²
        ctx.fillRect(this.x, this.y, this.w, this.h);
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x, this.y, this.w, this.h);
        
        // ã€ŒSã€ã®æ–‡å­—
        ctx.fillStyle = 'black';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText("S", this.x + this.w/2, this.y + this.h/2);
        ctx.restore();
    }
}

// æ˜Ÿï¼ˆèƒŒæ™¯ï¼‰
class Star {
    constructor() {
        this.reset();
        this.y = Math.random() * canvas.height; // åˆå›ã¯ç”»é¢å…¨ä½“ã«
    }
    reset() {
        this.x = Math.random() * canvas.width;
        this.y = 0;
        this.size = Math.random() * 2 + 0.5;
        this.speed = Math.random() * 5 + 1; // ç–¾èµ°æ„Ÿã‚’å‡ºã™ãŸã‚å°‘ã—é€Ÿã
    }
    update() {
        this.y += this.speed;
        if (this.y > canvas.height) this.reset();
    }
    draw() {
        ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.5})`;
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }
}

/* =========================================
   ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯
   ========================================= */

function init() {
    particles = [];
    for(let i=0; i<80; i++) particles.push(new Star());
    
    window.addEventListener('keydown', e => {
        if(keys.hasOwnProperty(e.code)) keys[e.code] = true;
        
        // 3ç§’å¾…æ©Ÿå¾Œã®ãƒªã‚¹ã‚¿ãƒ¼ãƒˆå‡¦ç†
        if (gameState === 'WAITING' && e.code === 'Space') {
            resetGame();
        }
        // åˆå›ã‚¹ã‚¿ãƒ¼ãƒˆ
        if (gameState === 'START' && e.code === 'Space') {
            resetGame();
        }
    });
    window.addEventListener('keyup', e => {
        if(keys.hasOwnProperty(e.code)) keys[e.code] = false;
    });

    requestAnimationFrame(gameLoop);
}

function resetGame() {
    player.x = 300; player.y = 700;
    player.bullets = [];
    player.shield = 0;
    player.invincible = 0;
    
    enemies = [];
    enemyBullets = [];
    powerUps = [];
    
    score = 0;
    difficulty = 1;
    frames = 0;
    
    updateUI();
    gameState = 'PLAYING';
}

function updateUI() {
    scoreEl.innerText = score;
    // ã‚·ãƒ¼ãƒ«ãƒ‰è¡¨ç¤ºã‚’è¨˜å·ã§
    shieldEl.innerText = "ğŸ›¡ï¸".repeat(player.shield) || "NONE";
}

function update() {
    if (gameState !== 'PLAYING') return;

    frames++;

    // é›£æ˜“åº¦èª¿æ•´ï¼šã‚¹ã‚³ã‚¢500ç‚¹ã”ã¨ã«é›£æ˜“åº¦UP
    difficulty = 1 + Math.floor(score / 500);

    // èƒŒæ™¯
    particles.forEach(p => p.update());

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•
    if (keys.ArrowLeft && player.x > 0) player.x -= player.speed;
    if (keys.ArrowRight && player.x < canvas.width - player.w) player.x += player.speed;
    if (keys.ArrowUp && player.y > 0) player.y -= player.speed;
    if (keys.ArrowDown && player.y < canvas.height - player.h) player.y += player.speed;

    // ç„¡æ•µæ™‚é–“ã®æ¸›å°‘
    if (player.invincible > 0) player.invincible--;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç™ºå°„ï¼ˆåŸºæœ¬ã¯2é€£è£…ã§å›ºå®šï¼‰
    if (keys.Space && frames - player.lastShotTime > player.shotDelay) {
        player.lastShotTime = frames;
        player.bullets.push({x: player.x, y: player.y, dx: 0, dy: -12});
        player.bullets.push({x: player.x + player.w, y: player.y, dx: 0, dy: -12});
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾æ›´æ–°
    for (let i = player.bullets.length - 1; i >= 0; i--) {
        let b = player.bullets[i];
        b.y += b.dy;
        if (b.y < 0) player.bullets.splice(i, 1);
    }

    // æ•µå‡ºç¾ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆé›£æ˜“åº¦ãŒä¸ŠãŒã‚‹ã¨å‡ºç¾é–“éš”ãŒçŸ­ããªã‚‹ï¼‰
    // æœ€é€Ÿã§20ãƒ•ãƒ¬ãƒ¼ãƒ ã«1ä½“
    let spawnRate = Math.max(20, 60 - (difficulty * 2));
    if (frames % spawnRate === 0) {
        enemies.push(new Enemy());
    }

    // æ•µã®å‡¦ç†
    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        e.update();

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾ã¨ã®å½“ãŸã‚Šåˆ¤å®š
        for (let j = player.bullets.length - 1; j >= 0; j--) {
            let b = player.bullets[j];
            if (isColliding({x: b.x-2, y: b.y, w:4, h:10}, {x: e.x, y: e.y, w: e.w, h: e.h})) {
                enemies.splice(i, 1);
                player.bullets.splice(j, 1);
                score += 10 + (difficulty * 2); // é›£æ˜“åº¦é«˜ã„ã¨ã‚¹ã‚³ã‚¢ã‚‚é«˜ã„
                updateUI();

                // ã‚·ãƒ¼ãƒ«ãƒ‰ã‚¢ã‚¤ãƒ†ãƒ ãƒ‰ãƒ­ãƒƒãƒ—ï¼ˆç¢ºç‡ã¯ä½ã‚ï¼š10%ï¼‰
                // ãŸã ã—ã‚·ãƒ¼ãƒ«ãƒ‰ãŒ0ã®æ™‚ã¯å°‘ã—å‡ºã‚„ã™ãã™ã‚‹(20%)
                let dropRate = player.shield === 0 ? 0.2 : 0.1;
                if (Math.random() < dropRate) {
                    powerUps.push(new ShieldItem(e.x, e.y));
                }
                break; 
            }
        }
        
        // ç”»é¢å¤–
        if (e.y > canvas.height + 50) {
            if (enemies[i]) enemies.splice(i, 1);
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è¡çª
        if (player.invincible === 0 && isColliding(player, {x: e.x, y: e.y, w: e.w, h: e.h})) {
            handlePlayerHit();
            // æ•µã‚‚æ¶ˆæ»…
            if (enemies[i]) enemies.splice(i, 1);
        }
    }

    // æ•µå¼¾ã®å‡¦ç†
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
        let eb = enemyBullets[i];
        eb.update();
        if (eb.y > canvas.height || eb.x < 0 || eb.x > canvas.width) {
            enemyBullets.splice(i, 1);
            continue;
        }
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¢«å¼¾åˆ¤å®š
        // å½“ãŸã‚Šåˆ¤å®šã‚’å°‘ã—å°ã•ãã—ã¦ã€Œé¿ã‘ã‚„ã™ãã€ã™ã‚‹ï¼ˆã‹ã™ã‚Šåˆ¤å®šï¼‰
        if (player.invincible === 0 && 
            isCircleRectColliding(eb, {x: player.x + 5, y: player.y + 5, w: player.w - 10, h: player.h - 10})) {
            handlePlayerHit();
            enemyBullets.splice(i, 1);
        }
    }

    // ã‚¢ã‚¤ãƒ†ãƒ å–å¾—å‡¦ç†
    for (let i = powerUps.length - 1; i >= 0; i--) {
        let p = powerUps[i];
        p.update();
        if (isColliding(player, p)) {
            if (player.shield < player.maxShield) {
                player.shield++;
                score += 500;
            } else {
                score += 1000; // ã‚«ãƒ³ã‚¹ãƒˆæ™‚ã¯ã‚¹ã‚³ã‚¢ãƒœãƒ¼ãƒŠã‚¹
            }
            updateUI();
            powerUps.splice(i, 1);
        } else if (p.y > canvas.height) {
            powerUps.splice(i, 1);
        }
    }
}

// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¢«å¼¾æ™‚ã®å‡¦ç†
function handlePlayerHit() {
    if (player.shield > 0) {
        player.shield--;
        player.invincible = 90; // 1.5ç§’ç„¡æ•µ
        updateUI();
        // ç”»é¢æºã‚‰ã—ç­‰ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å…¥ã‚ŒãŸã„ãŒä»Šå›ã¯çœç•¥
    } else {
        triggerGameOver();
    }
}

function triggerGameOver() {
    gameState = 'GAMEOVER';
    // 3ç§’å¾Œã«ãƒªãƒˆãƒ©ã‚¤å¯èƒ½çŠ¶æ…‹ã«ã™ã‚‹
    setTimeout(() => {
        gameState = 'WAITING';
    }, 3000);
}

// çŸ©å½¢åˆ¤å®š
function isColliding(r1, r2) {
    return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
}
// å††ã¨çŸ©å½¢ã®åˆ¤å®šï¼ˆæ•µå¼¾ç”¨ï¼‰
function isCircleRectColliding(circle, rect) {
    let testX = circle.x;
    let testY = circle.y;
    if (circle.x < rect.x) testX = rect.x;
    else if (circle.x > rect.x + rect.w) testX = rect.x + rect.w;
    if (circle.y < rect.y) testY = rect.y;
    else if (circle.y > rect.y + rect.h) testY = rect.y + rect.h;
    
    let distX = circle.x - testX;
    let distY = circle.y - testY;
    return (distX * distX + distY * distY) <= (circle.r * circle.r);
}

function draw() {
    // ç”»é¢ã‚¯ãƒªã‚¢
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // èƒŒæ™¯
    particles.forEach(p => p.draw());

    if (gameState === 'START') {
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.font = '50px Courier New';
        ctx.fillText("ASTRO FARMER", canvas.width/2, canvas.height/2 - 40);
        ctx.font = '20px Courier New';
        ctx.fillText("Collect Shields [S] to Survive", canvas.width/2, canvas.height/2 + 20);
        ctx.fillText("Press SPACE to Start", canvas.width/2, canvas.height/2 + 60);
        return;
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»
    if (player.invincible % 10 < 5) { // ç„¡æ•µæ™‚ã¯ç‚¹æ»…
        ctx.fillStyle = player.color;
        // ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ï¼ˆé•·æ–¹å½¢ï¼‰
        ctx.fillRect(player.x, player.y, player.w, player.h);

        // ã‚·ãƒ¼ãƒ«ãƒ‰å±•é–‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        if (player.shield > 0) {
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + (player.shield * 0.2)})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(player.x + player.w/2, player.y + player.h/2, 40, 0, Math.PI*2);
            ctx.stroke();
        }
    }

    // å¼¾
    ctx.fillStyle = 'yellow';
    player.bullets.forEach(b => ctx.fillRect(b.x - 2, b.y, 4, 12));

    // æ•µãƒ»ã‚¢ã‚¤ãƒ†ãƒ 
    enemies.forEach(e => e.draw());
    powerUps.forEach(p => p.draw());
    enemyBullets.forEach(eb => eb.draw());

    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢
    if (gameState === 'GAMEOVER' || gameState === 'WAITING') {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = 'red';
        ctx.textAlign = 'center';
        ctx.font = '60px Courier New';
        ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2 - 20);
        
        ctx.fillStyle = 'white';
        ctx.font = '30px Courier New';
        ctx.fillText("Final Score: " + score, canvas.width/2, canvas.height/2 + 50);

        if (gameState === 'WAITING') {
            ctx.fillStyle = '#00ffff'; // ã‚·ã‚¢ãƒ³è‰²ã§èª˜å°
            ctx.font = '20px Courier New';
            ctx.fillText("> Press SPACE to Retry <", canvas.width/2, canvas.height/2 + 100);
        } else {
            ctx.fillStyle = 'gray';
            ctx.font = '16px Courier New';
            ctx.fillText("Wait...", canvas.width/2, canvas.height/2 + 100);
        }
    }
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

init();

</script>
</body>
</html>